(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[49],{

/***/ "./node_modules/bip38/index.js":
/*!*************************************!*\
  !*** ./node_modules/bip38/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var aes = __webpack_require__(/*! browserify-aes */ \"./node_modules/browserify-aes/browser.js\")\nvar assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/bip38/node_modules/safe-buffer/index.js\").Buffer\nvar bs58check = __webpack_require__(/*! bs58check */ \"./node_modules/bs58check/index.js\")\nvar createHash = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\")\nvar scrypt = __webpack_require__(/*! scryptsy */ \"./node_modules/scryptsy/lib/index.js\")\nvar xor = __webpack_require__(/*! buffer-xor/inplace */ \"./node_modules/buffer-xor/inplace.js\")\n\nvar ecurve = __webpack_require__(/*! ecurve */ \"./node_modules/ecurve/lib/index.js\")\nvar curve = ecurve.getCurveByName('secp256k1')\n\nvar BigInteger = __webpack_require__(/*! bigi */ \"./node_modules/bigi/lib/index.js\")\n\n// constants\nvar SCRYPT_PARAMS = {\n  N: 16384, // specified by BIP38\n  r: 8,\n  p: 8\n}\nvar NULL = Buffer.alloc(0)\n\nfunction hash160 (buffer) {\n  var hash\n  try {\n    hash = createHash('rmd160')\n  } catch (e) {\n    hash = createHash('ripemd160')\n  }\n  return hash.update(\n    createHash('sha256').update(buffer).digest()\n  ).digest()\n}\n\nfunction hash256 (buffer) {\n  return createHash('sha256').update(\n    createHash('sha256').update(buffer).digest()\n  ).digest()\n}\n\nfunction getAddress (d, compressed) {\n  var Q = curve.G.multiply(d).getEncoded(compressed)\n  var hash = hash160(Q)\n  var payload = Buffer.allocUnsafe(21)\n  payload.writeUInt8(0x00, 0) // XXX TODO FIXME bitcoin only??? damn you BIP38\n  hash.copy(payload, 1)\n\n  return bs58check.encode(payload)\n}\n\nfunction prepareEncryptRaw (buffer, compressed, passphrase, scryptParams) {\n  if (buffer.length !== 32) throw new Error('Invalid private key length')\n\n  var d = BigInteger.fromBuffer(buffer)\n  var address = getAddress(d, compressed)\n  var secret = Buffer.from(passphrase.normalize('NFC'), 'utf8')\n  var salt = hash256(address).slice(0, 4)\n\n  var N = scryptParams.N\n  var r = scryptParams.r\n  var p = scryptParams.p\n\n  return {\n    secret,\n    salt,\n    N,\n    r,\n    p\n  }\n}\n\nfunction finishEncryptRaw (buffer, compressed, salt, scryptBuf) {\n  var derivedHalf1 = scryptBuf.slice(0, 32)\n  var derivedHalf2 = scryptBuf.slice(32, 64)\n\n  var xorBuf = xor(derivedHalf1, buffer)\n  var cipher = aes.createCipheriv('aes-256-ecb', derivedHalf2, NULL)\n  cipher.setAutoPadding(false)\n  cipher.end(xorBuf)\n\n  var cipherText = cipher.read()\n\n  // 0x01 | 0x42 | flagByte | salt (4) | cipherText (32)\n  var result = Buffer.allocUnsafe(7 + 32)\n  result.writeUInt8(0x01, 0)\n  result.writeUInt8(0x42, 1)\n  result.writeUInt8(compressed ? 0xe0 : 0xc0, 2)\n  salt.copy(result, 3)\n  cipherText.copy(result, 7)\n\n  return result\n}\n\nasync function encryptRawAsync (buffer, compressed, passphrase, progressCallback, scryptParams, promiseInterval) {\n  scryptParams = scryptParams || SCRYPT_PARAMS\n  const {\n    secret,\n    salt,\n    N,\n    r,\n    p\n  } = prepareEncryptRaw(buffer, compressed, passphrase, scryptParams)\n\n  var scryptBuf = await scrypt.async(secret, salt, N, r, p, 64, progressCallback, promiseInterval)\n\n  return finishEncryptRaw(buffer, compressed, salt, scryptBuf)\n}\n\nfunction encryptRaw (buffer, compressed, passphrase, progressCallback, scryptParams) {\n  scryptParams = scryptParams || SCRYPT_PARAMS\n  const {\n    secret,\n    salt,\n    N,\n    r,\n    p\n  } = prepareEncryptRaw(buffer, compressed, passphrase, scryptParams)\n\n  var scryptBuf = scrypt(secret, salt, N, r, p, 64, progressCallback)\n\n  return finishEncryptRaw(buffer, compressed, salt, scryptBuf)\n}\n\nasync function encryptAsync (buffer, compressed, passphrase, progressCallback, scryptParams, promiseInterval) {\n  return bs58check.encode(await encryptRawAsync(buffer, compressed, passphrase, progressCallback, scryptParams, promiseInterval))\n}\n\nfunction encrypt (buffer, compressed, passphrase, progressCallback, scryptParams) {\n  return bs58check.encode(encryptRaw(buffer, compressed, passphrase, progressCallback, scryptParams))\n}\n\nfunction prepareDecryptRaw (buffer, progressCallback, scryptParams) {\n  // 39 bytes: 2 bytes prefix, 37 bytes payload\n  if (buffer.length !== 39) throw new Error('Invalid BIP38 data length')\n  if (buffer.readUInt8(0) !== 0x01) throw new Error('Invalid BIP38 prefix')\n\n  // check if BIP38 EC multiply\n  var type = buffer.readUInt8(1)\n  if (type === 0x43) return { decryptEC: true }\n  if (type !== 0x42) throw new Error('Invalid BIP38 type')\n\n  var flagByte = buffer.readUInt8(2)\n  var compressed = flagByte === 0xe0\n  if (!compressed && flagByte !== 0xc0) throw new Error('Invalid BIP38 compression flag')\n\n  var N = scryptParams.N\n  var r = scryptParams.r\n  var p = scryptParams.p\n\n  var salt = buffer.slice(3, 7)\n  return {\n    salt,\n    compressed,\n    N,\n    r,\n    p\n  }\n}\n\nfunction finishDecryptRaw (buffer, salt, compressed, scryptBuf) {\n  var derivedHalf1 = scryptBuf.slice(0, 32)\n  var derivedHalf2 = scryptBuf.slice(32, 64)\n\n  var privKeyBuf = buffer.slice(7, 7 + 32)\n  var decipher = aes.createDecipheriv('aes-256-ecb', derivedHalf2, NULL)\n  decipher.setAutoPadding(false)\n  decipher.end(privKeyBuf)\n\n  var plainText = decipher.read()\n  var privateKey = xor(derivedHalf1, plainText)\n\n  // verify salt matches address\n  var d = BigInteger.fromBuffer(privateKey)\n  var address = getAddress(d, compressed)\n  var checksum = hash256(address).slice(0, 4)\n  assert.deepStrictEqual(salt, checksum)\n\n  return {\n    privateKey: privateKey,\n    compressed: compressed\n  }\n}\n\nasync function decryptRawAsync (buffer, passphrase, progressCallback, scryptParams, promiseInterval) {\n  scryptParams = scryptParams || SCRYPT_PARAMS\n  const {\n    salt,\n    compressed,\n    N,\n    r,\n    p,\n    decryptEC\n  } = prepareDecryptRaw(buffer, progressCallback, scryptParams)\n  if (decryptEC === true) return decryptECMultAsync(buffer, passphrase, progressCallback, scryptParams, promiseInterval)\n\n  var scryptBuf = await scrypt.async(passphrase.normalize('NFC'), salt, N, r, p, 64, progressCallback, promiseInterval)\n  return finishDecryptRaw(buffer, salt, compressed, scryptBuf)\n}\n\n// some of the techniques borrowed from: https://github.com/pointbiz/bitaddress.org\nfunction decryptRaw (buffer, passphrase, progressCallback, scryptParams) {\n  scryptParams = scryptParams || SCRYPT_PARAMS\n  const {\n    salt,\n    compressed,\n    N,\n    r,\n    p,\n    decryptEC\n  } = prepareDecryptRaw(buffer, progressCallback, scryptParams)\n  if (decryptEC === true) return decryptECMult(buffer, passphrase, progressCallback, scryptParams)\n  var scryptBuf = scrypt(passphrase.normalize('NFC'), salt, N, r, p, 64, progressCallback)\n  return finishDecryptRaw(buffer, salt, compressed, scryptBuf)\n}\n\nasync function decryptAsync (string, passphrase, progressCallback, scryptParams, promiseInterval) {\n  return decryptRawAsync(bs58check.decode(string), passphrase, progressCallback, scryptParams, promiseInterval)\n}\n\nfunction decrypt (string, passphrase, progressCallback, scryptParams) {\n  return decryptRaw(bs58check.decode(string), passphrase, progressCallback, scryptParams)\n}\n\nfunction prepareDecryptECMult (buffer, passphrase, progressCallback, scryptParams) {\n  var flag = buffer.readUInt8(1)\n  var compressed = (flag & 0x20) !== 0\n  var hasLotSeq = (flag & 0x04) !== 0\n\n  assert.strictEqual((flag & 0x24), flag, 'Invalid private key.')\n\n  var addressHash = buffer.slice(2, 6)\n  var ownerEntropy = buffer.slice(6, 14)\n  var ownerSalt\n\n  // 4 bytes ownerSalt if 4 bytes lot/sequence\n  if (hasLotSeq) {\n    ownerSalt = ownerEntropy.slice(0, 4)\n\n  // else, 8 bytes ownerSalt\n  } else {\n    ownerSalt = ownerEntropy\n  }\n\n  var encryptedPart1 = buffer.slice(14, 22) // First 8 bytes\n  var encryptedPart2 = buffer.slice(22, 38) // 16 bytes\n\n  var N = scryptParams.N\n  var r = scryptParams.r\n  var p = scryptParams.p\n  return {\n    addressHash,\n    encryptedPart1,\n    encryptedPart2,\n    ownerEntropy,\n    ownerSalt,\n    hasLotSeq,\n    compressed,\n    N,\n    r,\n    p\n  }\n}\n\nfunction getPassIntAndPoint (preFactor, ownerEntropy, hasLotSeq) {\n  var passFactor\n  if (hasLotSeq) {\n    var hashTarget = Buffer.concat([preFactor, ownerEntropy])\n    passFactor = hash256(hashTarget)\n  } else {\n    passFactor = preFactor\n  }\n  const passInt = BigInteger.fromBuffer(passFactor)\n  return {\n    passInt,\n    passPoint: curve.G.multiply(passInt).getEncoded(true)\n  }\n}\n\nfunction finishDecryptECMult (seedBPass, encryptedPart1, encryptedPart2, passInt, compressed) {\n  var derivedHalf1 = seedBPass.slice(0, 32)\n  var derivedHalf2 = seedBPass.slice(32, 64)\n\n  var decipher = aes.createDecipheriv('aes-256-ecb', derivedHalf2, Buffer.alloc(0))\n  decipher.setAutoPadding(false)\n  decipher.end(encryptedPart2)\n\n  var decryptedPart2 = decipher.read()\n  var tmp = xor(decryptedPart2, derivedHalf1.slice(16, 32))\n  var seedBPart2 = tmp.slice(8, 16)\n\n  var decipher2 = aes.createDecipheriv('aes-256-ecb', derivedHalf2, Buffer.alloc(0))\n  decipher2.setAutoPadding(false)\n  decipher2.write(encryptedPart1) // first 8 bytes\n  decipher2.end(tmp.slice(0, 8)) // last 8 bytes\n\n  var seedBPart1 = xor(decipher2.read(), derivedHalf1.slice(0, 16))\n  var seedB = Buffer.concat([seedBPart1, seedBPart2], 24)\n  var factorB = BigInteger.fromBuffer(hash256(seedB))\n\n  // d = passFactor * factorB (mod n)\n  var d = passInt.multiply(factorB).mod(curve.n)\n\n  return {\n    privateKey: d.toBuffer(32),\n    compressed: compressed\n  }\n}\n\nasync function decryptECMultAsync (buffer, passphrase, progressCallback, scryptParams, promiseInterval) {\n  buffer = buffer.slice(1) // FIXME: we can avoid this\n  passphrase = Buffer.from(passphrase.normalize('NFC'), 'utf8')\n  scryptParams = scryptParams || SCRYPT_PARAMS\n  const {\n    addressHash,\n    encryptedPart1,\n    encryptedPart2,\n    ownerEntropy,\n    ownerSalt,\n    hasLotSeq,\n    compressed,\n    N,\n    r,\n    p\n  } = prepareDecryptECMult(buffer, passphrase, progressCallback, scryptParams)\n\n  var preFactor = await scrypt.async(passphrase, ownerSalt, N, r, p, 32, progressCallback, promiseInterval)\n\n  const {\n    passInt,\n    passPoint\n  } = getPassIntAndPoint(preFactor, ownerEntropy, hasLotSeq)\n\n  var seedBPass = await scrypt.async(passPoint, Buffer.concat([addressHash, ownerEntropy]), 1024, 1, 1, 64, undefined, promiseInterval)\n\n  return finishDecryptECMult(seedBPass, encryptedPart1, encryptedPart2, passInt, compressed)\n}\n\nfunction decryptECMult (buffer, passphrase, progressCallback, scryptParams) {\n  buffer = buffer.slice(1) // FIXME: we can avoid this\n  passphrase = Buffer.from(passphrase.normalize('NFC'), 'utf8')\n  scryptParams = scryptParams || SCRYPT_PARAMS\n  const {\n    addressHash,\n    encryptedPart1,\n    encryptedPart2,\n    ownerEntropy,\n    ownerSalt,\n    hasLotSeq,\n    compressed,\n    N,\n    r,\n    p\n  } = prepareDecryptECMult(buffer, passphrase, progressCallback, scryptParams)\n  var preFactor = scrypt(passphrase, ownerSalt, N, r, p, 32, progressCallback)\n\n  const {\n    passInt,\n    passPoint\n  } = getPassIntAndPoint(preFactor, ownerEntropy, hasLotSeq)\n\n  var seedBPass = scrypt(passPoint, Buffer.concat([addressHash, ownerEntropy]), 1024, 1, 1, 64)\n\n  return finishDecryptECMult(seedBPass, encryptedPart1, encryptedPart2, passInt, compressed)\n}\n\nfunction verify (string) {\n  var decoded = bs58check.decodeUnsafe(string)\n  if (!decoded) return false\n\n  if (decoded.length !== 39) return false\n  if (decoded.readUInt8(0) !== 0x01) return false\n\n  var type = decoded.readUInt8(1)\n  var flag = decoded.readUInt8(2)\n\n  // encrypted WIF\n  if (type === 0x42) {\n    if (flag !== 0xc0 && flag !== 0xe0) return false\n\n  // EC mult\n  } else if (type === 0x43) {\n    if ((flag & ~0x24)) return false\n  } else {\n    return false\n  }\n\n  return true\n}\n\nmodule.exports = {\n  decrypt: decrypt,\n  decryptECMult: decryptECMult,\n  decryptRaw: decryptRaw,\n  encrypt: encrypt,\n  encryptRaw: encryptRaw,\n  decryptAsync: decryptAsync,\n  decryptECMultAsync: decryptECMultAsync,\n  decryptRawAsync: decryptRawAsync,\n  encryptAsync: encryptAsync,\n  encryptRawAsync: encryptRawAsync,\n  verify: verify\n}\n\n\n//# sourceURL=webpack:///./node_modules/bip38/index.js?");

/***/ }),

/***/ "./node_modules/bip38/node_modules/safe-buffer/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/bip38/node_modules/safe-buffer/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack:///./node_modules/bip38/node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "./node_modules/buffer-xor/inplace.js":
/*!********************************************!*\
  !*** ./node_modules/buffer-xor/inplace.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function xorInplace (a, b) {\n  var length = Math.min(a.length, b.length)\n\n  for (var i = 0; i < length; ++i) {\n    a[i] = a[i] ^ b[i]\n  }\n\n  return a.slice(0, length)\n}\n\n\n//# sourceURL=webpack:///./node_modules/buffer-xor/inplace.js?");

/***/ }),

/***/ "./node_modules/scryptsy/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/scryptsy/lib/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const scrypt = __webpack_require__(/*! ./scryptSync */ \"./node_modules/scryptsy/lib/scryptSync.js\")\nscrypt.async = __webpack_require__(/*! ./scrypt */ \"./node_modules/scryptsy/lib/scrypt.js\")\nmodule.exports = scrypt\n\n\n//# sourceURL=webpack:///./node_modules/scryptsy/lib/index.js?");

/***/ }),

/***/ "./node_modules/scryptsy/lib/scrypt.js":
/*!*********************************************!*\
  !*** ./node_modules/scryptsy/lib/scrypt.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const crypto = __webpack_require__(/*! crypto */ \"./node_modules/crypto-browserify/index.js\")\nconst {\n  checkAndInit,\n  smix\n} = __webpack_require__(/*! ./utils */ \"./node_modules/scryptsy/lib/utils.js\")\n\n// N = Cpu cost, r = Memory cost, p = parallelization cost\nasync function scrypt (key, salt, N, r, p, dkLen, progressCallback, promiseInterval) {\n  const {\n    XY,\n    V,\n    B32,\n    x,\n    _X,\n    B,\n    tickCallback\n  } = checkAndInit(key, salt, N, r, p, dkLen, progressCallback)\n\n  for (var i = 0; i < p; i++) {\n    await smix(B, i * 128 * r, r, N, V, XY, _X, B32, x, tickCallback, promiseInterval)\n  }\n\n  return crypto.pbkdf2Sync(key, B, 1, dkLen, 'sha256')\n}\n\nmodule.exports = scrypt\n\n\n//# sourceURL=webpack:///./node_modules/scryptsy/lib/scrypt.js?");

/***/ }),

/***/ "./node_modules/scryptsy/lib/scryptSync.js":
/*!*************************************************!*\
  !*** ./node_modules/scryptsy/lib/scryptSync.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const crypto = __webpack_require__(/*! crypto */ \"./node_modules/crypto-browserify/index.js\")\nconst {\n  checkAndInit,\n  smixSync\n} = __webpack_require__(/*! ./utils */ \"./node_modules/scryptsy/lib/utils.js\")\n\n// N = Cpu cost, r = Memory cost, p = parallelization cost\nfunction scrypt (key, salt, N, r, p, dkLen, progressCallback) {\n  const {\n    XY,\n    V,\n    B32,\n    x,\n    _X,\n    B,\n    tickCallback\n  } = checkAndInit(key, salt, N, r, p, dkLen, progressCallback)\n\n  for (var i = 0; i < p; i++) {\n    smixSync(B, i * 128 * r, r, N, V, XY, _X, B32, x, tickCallback)\n  }\n\n  return crypto.pbkdf2Sync(key, B, 1, dkLen, 'sha256')\n}\n\nmodule.exports = scrypt\n\n\n//# sourceURL=webpack:///./node_modules/scryptsy/lib/scryptSync.js?");

/***/ }),

/***/ "./node_modules/scryptsy/lib/utils.js":
/*!********************************************!*\
  !*** ./node_modules/scryptsy/lib/utils.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer, setImmediate) {const crypto = __webpack_require__(/*! crypto */ \"./node_modules/crypto-browserify/index.js\")\nconst MAX_VALUE = 0x7fffffff\nconst DEFAULT_PROMISE_INTERVAL = 5000\n/* eslint-disable camelcase */\n\nfunction checkAndInit (key, salt, N, r, p, dkLen, progressCallback) {\n  if (N === 0 || (N & (N - 1)) !== 0) throw Error('N must be > 0 and a power of 2')\n\n  if (N > MAX_VALUE / 128 / r) throw Error('Parameter N is too large')\n  if (r > MAX_VALUE / 128 / p) throw Error('Parameter r is too large')\n\n  let XY = Buffer.alloc(256 * r)\n  let V = Buffer.alloc(128 * r * N)\n\n  // pseudo global\n  let B32 = new Int32Array(16) // salsa20_8\n  let x = new Int32Array(16) // salsa20_8\n  let _X = Buffer.alloc(64) // blockmix_salsa8\n\n  // pseudo global\n  let B = crypto.pbkdf2Sync(key, salt, 1, p * 128 * r, 'sha256')\n\n  let tickCallback\n  if (progressCallback) {\n    let totalOps = p * N * 2\n    let currentOp = 0\n\n    tickCallback = function () {\n      ++currentOp\n\n      // send progress notifications once every 1,000 ops\n      if (currentOp % 1000 === 0) {\n        progressCallback({\n          current: currentOp,\n          total: totalOps,\n          percent: (currentOp / totalOps) * 100.0\n        })\n      }\n    }\n  }\n  return {\n    XY,\n    V,\n    B32,\n    x,\n    _X,\n    B,\n    tickCallback\n  }\n}\n\nasync function smix (B, Bi, r, N, V, XY, _X, B32, x, tickCallback, promiseInterval) {\n  promiseInterval = promiseInterval || DEFAULT_PROMISE_INTERVAL\n  let Xi = 0\n  let Yi = 128 * r\n  let i\n\n  B.copy(XY, Xi, Bi, Bi + Yi)\n\n  for (i = 0; i < N; i++) {\n    XY.copy(V, i * Yi, Xi, Xi + Yi)\n    if (i % promiseInterval === 0) {\n      await new Promise(resolve => setImmediate(resolve))\n    }\n    blockmix_salsa8(XY, Xi, Yi, r, _X, B32, x)\n\n    if (tickCallback) tickCallback()\n  }\n\n  for (i = 0; i < N; i++) {\n    let offset = Xi + (2 * r - 1) * 64\n    let j = XY.readUInt32LE(offset) & (N - 1)\n    blockxor(V, j * Yi, XY, Xi, Yi)\n    if (i % promiseInterval === 0) {\n      await new Promise(resolve => setImmediate(resolve))\n    }\n    blockmix_salsa8(XY, Xi, Yi, r, _X, B32, x)\n\n    if (tickCallback) tickCallback()\n  }\n\n  XY.copy(B, Bi, Xi, Xi + Yi)\n}\n\nfunction smixSync (B, Bi, r, N, V, XY, _X, B32, x, tickCallback) {\n  let Xi = 0\n  let Yi = 128 * r\n  let i\n\n  B.copy(XY, Xi, Bi, Bi + Yi)\n\n  for (i = 0; i < N; i++) {\n    XY.copy(V, i * Yi, Xi, Xi + Yi)\n    blockmix_salsa8(XY, Xi, Yi, r, _X, B32, x)\n\n    if (tickCallback) tickCallback()\n  }\n\n  for (i = 0; i < N; i++) {\n    let offset = Xi + (2 * r - 1) * 64\n    let j = XY.readUInt32LE(offset) & (N - 1)\n    blockxor(V, j * Yi, XY, Xi, Yi)\n    blockmix_salsa8(XY, Xi, Yi, r, _X, B32, x)\n\n    if (tickCallback) tickCallback()\n  }\n\n  XY.copy(B, Bi, Xi, Xi + Yi)\n}\n\nfunction blockmix_salsa8 (BY, Bi, Yi, r, _X, B32, x) {\n  let i\n\n  arraycopy(BY, Bi + (2 * r - 1) * 64, _X, 0, 64)\n\n  for (i = 0; i < 2 * r; i++) {\n    blockxor(BY, i * 64, _X, 0, 64)\n    salsa20_8(_X, B32, x)\n    arraycopy(_X, 0, BY, Yi + (i * 64), 64)\n  }\n\n  for (i = 0; i < r; i++) {\n    arraycopy(BY, Yi + (i * 2) * 64, BY, Bi + (i * 64), 64)\n  }\n\n  for (i = 0; i < r; i++) {\n    arraycopy(BY, Yi + (i * 2 + 1) * 64, BY, Bi + (i + r) * 64, 64)\n  }\n}\n\nfunction R (a, b) {\n  return (a << b) | (a >>> (32 - b))\n}\n\nfunction salsa20_8 (B, B32, x) {\n  let i\n\n  for (i = 0; i < 16; i++) {\n    B32[i] = (B[i * 4 + 0] & 0xff) << 0\n    B32[i] |= (B[i * 4 + 1] & 0xff) << 8\n    B32[i] |= (B[i * 4 + 2] & 0xff) << 16\n    B32[i] |= (B[i * 4 + 3] & 0xff) << 24\n    // B32[i] = B.readUInt32LE(i*4)   <--- this is signficantly slower even in Node.js\n  }\n\n  arraycopy(B32, 0, x, 0, 16)\n\n  for (i = 8; i > 0; i -= 2) {\n    x[4] ^= R(x[0] + x[12], 7)\n    x[8] ^= R(x[4] + x[0], 9)\n    x[12] ^= R(x[8] + x[4], 13)\n    x[0] ^= R(x[12] + x[8], 18)\n    x[9] ^= R(x[5] + x[1], 7)\n    x[13] ^= R(x[9] + x[5], 9)\n    x[1] ^= R(x[13] + x[9], 13)\n    x[5] ^= R(x[1] + x[13], 18)\n    x[14] ^= R(x[10] + x[6], 7)\n    x[2] ^= R(x[14] + x[10], 9)\n    x[6] ^= R(x[2] + x[14], 13)\n    x[10] ^= R(x[6] + x[2], 18)\n    x[3] ^= R(x[15] + x[11], 7)\n    x[7] ^= R(x[3] + x[15], 9)\n    x[11] ^= R(x[7] + x[3], 13)\n    x[15] ^= R(x[11] + x[7], 18)\n    x[1] ^= R(x[0] + x[3], 7)\n    x[2] ^= R(x[1] + x[0], 9)\n    x[3] ^= R(x[2] + x[1], 13)\n    x[0] ^= R(x[3] + x[2], 18)\n    x[6] ^= R(x[5] + x[4], 7)\n    x[7] ^= R(x[6] + x[5], 9)\n    x[4] ^= R(x[7] + x[6], 13)\n    x[5] ^= R(x[4] + x[7], 18)\n    x[11] ^= R(x[10] + x[9], 7)\n    x[8] ^= R(x[11] + x[10], 9)\n    x[9] ^= R(x[8] + x[11], 13)\n    x[10] ^= R(x[9] + x[8], 18)\n    x[12] ^= R(x[15] + x[14], 7)\n    x[13] ^= R(x[12] + x[15], 9)\n    x[14] ^= R(x[13] + x[12], 13)\n    x[15] ^= R(x[14] + x[13], 18)\n  }\n\n  for (i = 0; i < 16; ++i) B32[i] = x[i] + B32[i]\n\n  for (i = 0; i < 16; i++) {\n    let bi = i * 4\n    B[bi + 0] = (B32[i] >> 0 & 0xff)\n    B[bi + 1] = (B32[i] >> 8 & 0xff)\n    B[bi + 2] = (B32[i] >> 16 & 0xff)\n    B[bi + 3] = (B32[i] >> 24 & 0xff)\n    // B.writeInt32LE(B32[i], i*4)  //<--- this is signficantly slower even in Node.js\n  }\n}\n\n// naive approach... going back to loop unrolling may yield additional performance\nfunction blockxor (S, Si, D, Di, len) {\n  for (let i = 0; i < len; i++) {\n    D[Di + i] ^= S[Si + i]\n  }\n}\n\nfunction arraycopy (src, srcPos, dest, destPos, length) {\n  if (Buffer.isBuffer(src) && Buffer.isBuffer(dest)) {\n    src.copy(dest, destPos, srcPos, srcPos + length)\n  } else {\n    while (length--) {\n      dest[destPos++] = src[srcPos++]\n    }\n  }\n}\n\nmodule.exports = {\n  checkAndInit,\n  smix,\n  smixSync\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer, __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/scryptsy/lib/utils.js?");

/***/ })

}]);