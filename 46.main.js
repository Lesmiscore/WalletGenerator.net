(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[46],{

/***/ "./node_modules/base-x/src/index.js":
/*!******************************************!*\
  !*** ./node_modules/base-x/src/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n\n\n//# sourceURL=webpack:///./node_modules/base-x/src/index.js?");

/***/ }),

/***/ "./node_modules/ripple-address-codec/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/ripple-address-codec/dist/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;\nconst xrp_codec_1 = __webpack_require__(/*! ./xrp-codec */ \"./node_modules/ripple-address-codec/dist/xrp-codec.js\");\nObject.defineProperty(exports, \"codec\", { enumerable: true, get: function () { return xrp_codec_1.codec; } });\nObject.defineProperty(exports, \"encodeSeed\", { enumerable: true, get: function () { return xrp_codec_1.encodeSeed; } });\nObject.defineProperty(exports, \"decodeSeed\", { enumerable: true, get: function () { return xrp_codec_1.decodeSeed; } });\nObject.defineProperty(exports, \"encodeAccountID\", { enumerable: true, get: function () { return xrp_codec_1.encodeAccountID; } });\nObject.defineProperty(exports, \"decodeAccountID\", { enumerable: true, get: function () { return xrp_codec_1.decodeAccountID; } });\nObject.defineProperty(exports, \"encodeNodePublic\", { enumerable: true, get: function () { return xrp_codec_1.encodeNodePublic; } });\nObject.defineProperty(exports, \"decodeNodePublic\", { enumerable: true, get: function () { return xrp_codec_1.decodeNodePublic; } });\nObject.defineProperty(exports, \"encodeAccountPublic\", { enumerable: true, get: function () { return xrp_codec_1.encodeAccountPublic; } });\nObject.defineProperty(exports, \"decodeAccountPublic\", { enumerable: true, get: function () { return xrp_codec_1.decodeAccountPublic; } });\nObject.defineProperty(exports, \"isValidClassicAddress\", { enumerable: true, get: function () { return xrp_codec_1.isValidClassicAddress; } });\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst PREFIX_BYTES = {\n    MAIN: Buffer.from([0x05, 0x44]),\n    TEST: Buffer.from([0x04, 0x93]) // 4, 147\n};\nfunction classicAddressToXAddress(classicAddress, tag, test) {\n    const accountId = xrp_codec_1.decodeAccountID(classicAddress);\n    return encodeXAddress(accountId, tag, test);\n}\nexports.classicAddressToXAddress = classicAddressToXAddress;\nfunction encodeXAddress(accountId, tag, test) {\n    if (accountId.length !== 20) {\n        // RIPEMD160 is 160 bits = 20 bytes\n        throw new Error('Account ID must be 20 bytes');\n    }\n    const MAX_32_BIT_UNSIGNED_INT = 4294967295;\n    const flag = tag === false ? 0 : tag <= MAX_32_BIT_UNSIGNED_INT ? 1 : 2;\n    if (flag === 2) {\n        throw new Error('Invalid tag');\n    }\n    if (tag === false) {\n        tag = 0;\n    }\n    const bytes = Buffer.concat([\n        test ? PREFIX_BYTES.TEST : PREFIX_BYTES.MAIN,\n        accountId,\n        Buffer.from([\n            flag,\n            tag & 0xff,\n            (tag >> 8) & 0xff,\n            (tag >> 16) & 0xff,\n            (tag >> 24) & 0xff,\n            0, 0, 0, 0 // four zero bytes (reserved for 64-bit tags)\n        ])\n    ]);\n    const xAddress = xrp_codec_1.codec.encodeChecked(bytes);\n    return xAddress;\n}\nexports.encodeXAddress = encodeXAddress;\nfunction xAddressToClassicAddress(xAddress) {\n    const { accountId, tag, test } = decodeXAddress(xAddress);\n    const classicAddress = xrp_codec_1.encodeAccountID(accountId);\n    return {\n        classicAddress,\n        tag,\n        test\n    };\n}\nexports.xAddressToClassicAddress = xAddressToClassicAddress;\nfunction decodeXAddress(xAddress) {\n    const decoded = xrp_codec_1.codec.decodeChecked(xAddress);\n    const test = isBufferForTestAddress(decoded);\n    const accountId = decoded.slice(2, 22);\n    const tag = tagFromBuffer(decoded);\n    return {\n        accountId,\n        tag,\n        test\n    };\n}\nexports.decodeXAddress = decodeXAddress;\nfunction isBufferForTestAddress(buf) {\n    const decodedPrefix = buf.slice(0, 2);\n    if (PREFIX_BYTES.MAIN.equals(decodedPrefix)) {\n        return false;\n    }\n    else if (PREFIX_BYTES.TEST.equals(decodedPrefix)) {\n        return true;\n    }\n    else {\n        throw new Error('Invalid X-address: bad prefix');\n    }\n}\nfunction tagFromBuffer(buf) {\n    const flag = buf[22];\n    if (flag >= 2) {\n        // No support for 64-bit tags at this time\n        throw new Error('Unsupported X-address');\n    }\n    if (flag === 1) {\n        // Little-endian to big-endian\n        return buf[23] + buf[24] * 0x100 + buf[25] * 0x10000 + buf[26] * 0x1000000;\n    }\n    assert.strictEqual(flag, 0, 'flag must be zero to indicate no tag');\n    assert.ok(Buffer.from('0000000000000000', 'hex').equals(buf.slice(23, 23 + 8)), 'remaining bytes must be zero');\n    return false;\n}\nfunction isValidXAddress(xAddress) {\n    try {\n        decodeXAddress(xAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.isValidXAddress = isValidXAddress;\n//# sourceMappingURL=index.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/ripple-address-codec/dist/index.js?");

/***/ }),

/***/ "./node_modules/ripple-address-codec/dist/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/ripple-address-codec/dist/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.concatArgs = exports.seqEqual = void 0;\n/**\n * Check whether two sequences (e.g. arrays of numbers) are equal.\n *\n * @param arr1 One of the arrays to compare.\n * @param arr2 The other array to compare.\n */\nfunction seqEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let i = 0; i < arr1.length; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.seqEqual = seqEqual;\n/**\n * Check whether a value is a sequence (e.g. array of numbers).\n *\n * @param val The value to check.\n */\nfunction isSequence(val) {\n    return val.length !== undefined;\n}\n/**\n* Concatenate all `arguments` into a single array. Each argument can be either\n* a single element or a sequence, which has a `length` property and supports\n* element retrieval via sequence[ix].\n*\n* > concatArgs(1, [2, 3], Buffer.from([4,5]), new Uint8Array([6, 7]));\n*  [1,2,3,4,5,6,7]\n*\n* @returns {number[]} Array of concatenated arguments\n*/\nfunction concatArgs(...args) {\n    const ret = [];\n    args.forEach(function (arg) {\n        if (isSequence(arg)) {\n            for (let j = 0; j < arg.length; j++) {\n                ret.push(arg[j]);\n            }\n        }\n        else {\n            ret.push(arg);\n        }\n    });\n    return ret;\n}\nexports.concatArgs = concatArgs;\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack:///./node_modules/ripple-address-codec/dist/utils.js?");

/***/ }),

/***/ "./node_modules/ripple-address-codec/dist/xrp-codec.js":
/*!*************************************************************!*\
  !*** ./node_modules/ripple-address-codec/dist/xrp-codec.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n/**\n * Codec class\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.encodeNodePublic = exports.decodeNodePublic = exports.decodeAddress = exports.decodeAccountID = exports.encodeAddress = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;\nconst baseCodec = __webpack_require__(/*! base-x */ \"./node_modules/base-x/src/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/ripple-address-codec/dist/utils.js\");\nclass Codec {\n    constructor(options) {\n        this.sha256 = options.sha256;\n        this.alphabet = options.alphabet;\n        this.codec = baseCodec(this.alphabet);\n        this.base = this.alphabet.length;\n    }\n    /**\n     * Encoder.\n     *\n     * @param bytes Buffer of data to encode.\n     * @param opts Options object including the version bytes and the expected length of the data to encode.\n     */\n    encode(bytes, opts) {\n        const versions = opts.versions;\n        return this.encodeVersioned(bytes, versions, opts.expectedLength);\n    }\n    encodeVersioned(bytes, versions, expectedLength) {\n        if (expectedLength && bytes.length !== expectedLength) {\n            throw new Error('unexpected_payload_length: bytes.length does not match expectedLength.' +\n                ' Ensure that the bytes are a Buffer.');\n        }\n        return this.encodeChecked(Buffer.from(utils_1.concatArgs(versions, bytes)));\n    }\n    encodeChecked(buffer) {\n        const check = this.sha256(this.sha256(buffer)).slice(0, 4);\n        return this.encodeRaw(Buffer.from(utils_1.concatArgs(buffer, check)));\n    }\n    encodeRaw(bytes) {\n        return this.codec.encode(bytes);\n    }\n    /**\n     * Decoder.\n     *\n     * @param base58string Base58Check-encoded string to decode.\n     * @param opts Options object including the version byte(s) and the expected length of the data after decoding.\n     */\n    decode(base58string, opts) {\n        const versions = opts.versions;\n        const types = opts.versionTypes;\n        const withoutSum = this.decodeChecked(base58string);\n        if (versions.length > 1 && !opts.expectedLength) {\n            throw new Error('expectedLength is required because there are >= 2 possible versions');\n        }\n        const versionLengthGuess = typeof versions[0] === 'number' ? 1 : versions[0].length;\n        const payloadLength = opts.expectedLength || withoutSum.length - versionLengthGuess;\n        const versionBytes = withoutSum.slice(0, -payloadLength);\n        const payload = withoutSum.slice(-payloadLength);\n        for (let i = 0; i < versions.length; i++) {\n            const version = Array.isArray(versions[i]) ? versions[i] : [versions[i]];\n            if (utils_1.seqEqual(versionBytes, version)) {\n                return {\n                    version,\n                    bytes: payload,\n                    type: types ? types[i] : null\n                };\n            }\n        }\n        throw new Error('version_invalid: version bytes do not match any of the provided version(s)');\n    }\n    decodeChecked(base58string) {\n        const buffer = this.decodeRaw(base58string);\n        if (buffer.length < 5) {\n            throw new Error('invalid_input_size: decoded data must have length >= 5');\n        }\n        if (!this.verifyCheckSum(buffer)) {\n            throw new Error('checksum_invalid');\n        }\n        return buffer.slice(0, -4);\n    }\n    decodeRaw(base58string) {\n        return this.codec.decode(base58string);\n    }\n    verifyCheckSum(bytes) {\n        const computed = this.sha256(this.sha256(bytes.slice(0, -4))).slice(0, 4);\n        const checksum = bytes.slice(-4);\n        return utils_1.seqEqual(computed, checksum);\n    }\n}\n/**\n * XRP codec\n */\n// Pure JavaScript hash functions in the browser, native hash functions in Node.js\nconst createHash = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\");\n// base58 encodings: https://xrpl.org/base58-encodings.html\nconst ACCOUNT_ID = 0; // Account address (20 bytes)\nconst ACCOUNT_PUBLIC_KEY = 0x23; // Account public key (33 bytes)\nconst FAMILY_SEED = 0x21; // 33; Seed value (for secret keys) (16 bytes)\nconst NODE_PUBLIC = 0x1C; // 28; Validation public key (33 bytes)\nconst ED25519_SEED = [0x01, 0xE1, 0x4B]; // [1, 225, 75]\nconst codecOptions = {\n    sha256: function (bytes) {\n        return createHash('sha256').update(Buffer.from(bytes)).digest();\n    },\n    alphabet: 'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\n};\nconst codecWithXrpAlphabet = new Codec(codecOptions);\nexports.codec = codecWithXrpAlphabet;\n// entropy is a Buffer of size 16\n// type is 'ed25519' or 'secp256k1'\nfunction encodeSeed(entropy, type) {\n    if (entropy.length !== 16) {\n        throw new Error('entropy must have length 16');\n    }\n    const opts = {\n        expectedLength: 16,\n        // for secp256k1, use `FAMILY_SEED`\n        versions: type === 'ed25519' ? ED25519_SEED : [FAMILY_SEED]\n    };\n    // prefixes entropy with version bytes\n    return codecWithXrpAlphabet.encode(entropy, opts);\n}\nexports.encodeSeed = encodeSeed;\nfunction decodeSeed(seed, opts = {\n    versionTypes: ['ed25519', 'secp256k1'],\n    versions: [ED25519_SEED, FAMILY_SEED],\n    expectedLength: 16\n}) {\n    return codecWithXrpAlphabet.decode(seed, opts);\n}\nexports.decodeSeed = decodeSeed;\nfunction encodeAccountID(bytes) {\n    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };\n    return codecWithXrpAlphabet.encode(bytes, opts);\n}\nexports.encodeAccountID = encodeAccountID;\nexports.encodeAddress = encodeAccountID;\nfunction decodeAccountID(accountId) {\n    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };\n    return codecWithXrpAlphabet.decode(accountId, opts).bytes;\n}\nexports.decodeAccountID = decodeAccountID;\nexports.decodeAddress = decodeAccountID;\nfunction decodeNodePublic(base58string) {\n    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };\n    return codecWithXrpAlphabet.decode(base58string, opts).bytes;\n}\nexports.decodeNodePublic = decodeNodePublic;\nfunction encodeNodePublic(bytes) {\n    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };\n    return codecWithXrpAlphabet.encode(bytes, opts);\n}\nexports.encodeNodePublic = encodeNodePublic;\nfunction encodeAccountPublic(bytes) {\n    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };\n    return codecWithXrpAlphabet.encode(bytes, opts);\n}\nexports.encodeAccountPublic = encodeAccountPublic;\nfunction decodeAccountPublic(base58string) {\n    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };\n    return codecWithXrpAlphabet.decode(base58string, opts).bytes;\n}\nexports.decodeAccountPublic = decodeAccountPublic;\nfunction isValidClassicAddress(address) {\n    try {\n        decodeAccountID(address);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.isValidClassicAddress = isValidClassicAddress;\n//# sourceMappingURL=xrp-codec.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/ripple-address-codec/dist/xrp-codec.js?");

/***/ }),

/***/ "./node_modules/ripple-keypairs/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ripple-keypairs/dist/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst brorand = __webpack_require__(/*! brorand */ \"./node_modules/brorand/index.js\");\nconst hashjs = __webpack_require__(/*! hash.js */ \"./node_modules/hash.js/lib/hash.js\");\nconst elliptic = __webpack_require__(/*! elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nconst addressCodec = __webpack_require__(/*! ripple-address-codec */ \"./node_modules/ripple-address-codec/dist/index.js\");\nconst secp256k1_1 = __webpack_require__(/*! ./secp256k1 */ \"./node_modules/ripple-keypairs/dist/secp256k1.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/ripple-keypairs/dist/utils.js\");\nconst Ed25519 = elliptic.eddsa('ed25519');\nconst Secp256k1 = elliptic.ec('secp256k1');\nconst { hexToBytes } = utils;\nconst { bytesToHex } = utils;\nfunction generateSeed(options = {}) {\n    assert(!options.entropy || options.entropy.length >= 16, 'entropy too short');\n    const entropy = options.entropy ? options.entropy.slice(0, 16) : brorand(16);\n    const type = options.algorithm === 'ed25519' ? 'ed25519' : 'secp256k1';\n    return addressCodec.encodeSeed(entropy, type);\n}\nfunction hash(message) {\n    return hashjs\n        .sha512()\n        .update(message)\n        .digest()\n        .slice(0, 32);\n}\nconst secp256k1 = {\n    deriveKeypair(entropy, options) {\n        const prefix = '00';\n        const privateKey = prefix +\n            secp256k1_1.derivePrivateKey(entropy, options)\n                .toString(16, 64)\n                .toUpperCase();\n        const publicKey = bytesToHex(Secp256k1.keyFromPrivate(privateKey.slice(2))\n            .getPublic()\n            .encodeCompressed());\n        return { privateKey, publicKey };\n    },\n    sign(message, privateKey) {\n        return bytesToHex(Secp256k1.sign(hash(message), hexToBytes(privateKey), {\n            canonical: true,\n        }).toDER());\n    },\n    verify(message, signature, publicKey) {\n        return Secp256k1.verify(hash(message), signature, hexToBytes(publicKey));\n    },\n};\nconst ed25519 = {\n    deriveKeypair(entropy) {\n        const prefix = 'ED';\n        const rawPrivateKey = hash(entropy);\n        const privateKey = prefix + bytesToHex(rawPrivateKey);\n        const publicKey = prefix + bytesToHex(Ed25519.keyFromSecret(rawPrivateKey).pubBytes());\n        return { privateKey, publicKey };\n    },\n    sign(message, privateKey) {\n        // caution: Ed25519.sign interprets all strings as hex, stripping\n        // any non-hex characters without warning\n        assert(Array.isArray(message), 'message must be array of octets');\n        return bytesToHex(Ed25519.sign(message, hexToBytes(privateKey).slice(1)).toBytes());\n    },\n    verify(message, signature, publicKey) {\n        return Ed25519.verify(message, hexToBytes(signature), hexToBytes(publicKey).slice(1));\n    },\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction select(algorithm) {\n    const methods = { 'ecdsa-secp256k1': secp256k1, ed25519 };\n    return methods[algorithm];\n}\nfunction deriveKeypair(seed, options) {\n    const decoded = addressCodec.decodeSeed(seed);\n    const algorithm = decoded.type === 'ed25519' ? 'ed25519' : 'ecdsa-secp256k1';\n    const method = select(algorithm);\n    const keypair = method.deriveKeypair(decoded.bytes, options);\n    const messageToVerify = hash('This test message should verify.');\n    const signature = method.sign(messageToVerify, keypair.privateKey);\n    /* istanbul ignore if */\n    if (method.verify(messageToVerify, signature, keypair.publicKey) !== true) {\n        throw new Error('derived keypair did not generate verifiable signature');\n    }\n    return keypair;\n}\nfunction getAlgorithmFromKey(key) {\n    const bytes = hexToBytes(key);\n    return bytes.length === 33 && bytes[0] === 0xed\n        ? 'ed25519'\n        : 'ecdsa-secp256k1';\n}\nfunction sign(messageHex, privateKey) {\n    const algorithm = getAlgorithmFromKey(privateKey);\n    return select(algorithm).sign(hexToBytes(messageHex), privateKey);\n}\nfunction verify(messageHex, signature, publicKey) {\n    const algorithm = getAlgorithmFromKey(publicKey);\n    return select(algorithm).verify(hexToBytes(messageHex), signature, publicKey);\n}\nfunction deriveAddressFromBytes(publicKeyBytes) {\n    return addressCodec.encodeAccountID(utils.computePublicKeyHash(publicKeyBytes));\n}\nfunction deriveAddress(publicKey) {\n    return deriveAddressFromBytes(Buffer.from(hexToBytes(publicKey)));\n}\nfunction deriveNodeAddress(publicKey) {\n    const generatorBytes = addressCodec.decodeNodePublic(publicKey);\n    const accountPublicBytes = secp256k1_1.accountPublicFromPublicGenerator(generatorBytes);\n    return deriveAddressFromBytes(accountPublicBytes);\n}\nconst { decodeSeed } = addressCodec;\nmodule.exports = {\n    generateSeed,\n    deriveKeypair,\n    sign,\n    verify,\n    deriveAddress,\n    deriveNodeAddress,\n    decodeSeed,\n};\n//# sourceMappingURL=index.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/ripple-keypairs/dist/index.js?");

/***/ }),

/***/ "./node_modules/ripple-keypairs/dist/secp256k1.js":
/*!********************************************************!*\
  !*** ./node_modules/ripple-keypairs/dist/secp256k1.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.accountPublicFromPublicGenerator = exports.derivePrivateKey = void 0;\nconst elliptic = __webpack_require__(/*! elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nconst sha512_1 = __webpack_require__(/*! ./sha512 */ \"./node_modules/ripple-keypairs/dist/sha512.js\");\nconst secp256k1 = elliptic.ec('secp256k1');\nfunction deriveScalar(bytes, discrim) {\n    const order = secp256k1.curve.n;\n    for (let i = 0; i <= 0xffffffff; i++) {\n        // We hash the bytes to find a 256 bit number, looping until we are sure it\n        // is less than the order of the curve.\n        const hasher = new sha512_1.default().add(bytes);\n        // If the optional discriminator index was passed in, update the hash.\n        if (discrim !== undefined) {\n            hasher.addU32(discrim);\n        }\n        hasher.addU32(i);\n        const key = hasher.first256BN();\n        /* istanbul ignore else */\n        if (key.cmpn(0) > 0 && key.cmp(order) < 0) {\n            return key;\n        }\n    }\n    /* This error is practically impossible to reach.\n     * The order of the curve describes the (finite) amount of points on the curve\n     * https://github.com/indutny/elliptic/blob/master/lib/elliptic/curves.js#L182\n     * How often will an (essentially) random number generated by Sha512 be larger than that?\n     * There's 2^32 chances (the for loop) to get a number smaller than the order,\n     * and it's rare that you'll even get past the first loop iteration.\n     * Note that in TypeScript we actually need the throw, otherwise the function signature would be BN | undefined\n     */\n    /* istanbul ignore next */\n    throw new Error('impossible unicorn ;)');\n}\n/**\n * @param {Array} seed - bytes\n * @param {Object} [opts] - object\n * @param {Number} [opts.accountIndex=0] - the account number to generate\n * @param {Boolean} [opts.validator=false] - generate root key-pair,\n *                                              as used by validators.\n * @return {bn.js} - 256 bit scalar value\n *\n */\nfunction derivePrivateKey(seed, opts = {}) {\n    const root = opts.validator;\n    const order = secp256k1.curve.n;\n    // This private generator represents the `root` private key, and is what's\n    // used by validators for signing when a keypair is generated from a seed.\n    const privateGen = deriveScalar(seed);\n    if (root) {\n        // As returned by validation_create for a given seed\n        return privateGen;\n    }\n    const publicGen = secp256k1.g.mul(privateGen);\n    // A seed can generate many keypairs as a function of the seed and a uint32.\n    // Almost everyone just uses the first account, `0`.\n    const accountIndex = opts.accountIndex || 0;\n    return deriveScalar(publicGen.encodeCompressed(), accountIndex)\n        .add(privateGen)\n        .mod(order);\n}\nexports.derivePrivateKey = derivePrivateKey;\nfunction accountPublicFromPublicGenerator(publicGenBytes) {\n    const rootPubPoint = secp256k1.curve.decodePoint(publicGenBytes);\n    const scalar = deriveScalar(publicGenBytes, 0);\n    const point = secp256k1.g.mul(scalar);\n    const offset = rootPubPoint.add(point);\n    return offset.encodeCompressed();\n}\nexports.accountPublicFromPublicGenerator = accountPublicFromPublicGenerator;\n//# sourceMappingURL=secp256k1.js.map\n\n//# sourceURL=webpack:///./node_modules/ripple-keypairs/dist/secp256k1.js?");

/***/ }),

/***/ "./node_modules/ripple-keypairs/dist/sha512.js":
/*!*****************************************************!*\
  !*** ./node_modules/ripple-keypairs/dist/sha512.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst hashjs = __webpack_require__(/*! hash.js */ \"./node_modules/hash.js/lib/hash.js\");\nconst BigNum = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nclass Sha512 {\n    constructor() {\n        this.hash = hashjs.sha512();\n    }\n    add(bytes) {\n        this.hash.update(bytes);\n        return this;\n    }\n    addU32(i) {\n        return this.add([\n            (i >>> 24) & 0xff,\n            (i >>> 16) & 0xff,\n            (i >>> 8) & 0xff,\n            i & 0xff,\n        ]);\n    }\n    finish() {\n        return this.hash.digest();\n    }\n    first256() {\n        return this.finish().slice(0, 32);\n    }\n    first256BN() {\n        return new BigNum(this.first256());\n    }\n}\nexports.default = Sha512;\n//# sourceMappingURL=sha512.js.map\n\n//# sourceURL=webpack:///./node_modules/ripple-keypairs/dist/sha512.js?");

/***/ }),

/***/ "./node_modules/ripple-keypairs/dist/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/ripple-keypairs/dist/utils.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computePublicKeyHash = exports.hexToBytes = exports.bytesToHex = void 0;\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/node-libs-browser/node_modules/assert/assert.js\");\nconst hashjs = __webpack_require__(/*! hash.js */ \"./node_modules/hash.js/lib/hash.js\");\nconst BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nfunction bytesToHex(a) {\n    return a\n        .map((byteValue) => {\n        const hex = byteValue.toString(16).toUpperCase();\n        return hex.length > 1 ? hex : `0${hex}`;\n    })\n        .join('');\n}\nexports.bytesToHex = bytesToHex;\nfunction hexToBytes(a) {\n    assert(a.length % 2 === 0);\n    return new BN(a, 16).toArray(null, a.length / 2);\n}\nexports.hexToBytes = hexToBytes;\nfunction computePublicKeyHash(publicKeyBytes) {\n    const hash256 = hashjs\n        .sha256()\n        .update(publicKeyBytes)\n        .digest();\n    const hash160 = hashjs\n        .ripemd160()\n        .update(hash256)\n        .digest();\n    return Buffer.from(hash160);\n}\nexports.computePublicKeyHash = computePublicKeyHash;\n//# sourceMappingURL=utils.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/ripple-keypairs/dist/utils.js?");

/***/ })

}]);