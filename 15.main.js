(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[15],{

/***/ "./src/ninja.privatekey.js":
/*!*********************************!*\
  !*** ./src/ninja.privatekey.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = async function () {\n  const bitcoin = await Promise.all(/*! import() */[__webpack_require__.e(1), __webpack_require__.e(2), __webpack_require__.e(3), __webpack_require__.e(5), __webpack_require__.e(6), __webpack_require__.e(7), __webpack_require__.e(4), __webpack_require__.e(8), __webpack_require__.e(10), __webpack_require__.e(11), __webpack_require__.e(25)]).then(__webpack_require__.t.bind(null, /*! bitgo-utxo-lib */ \"./node_modules/bitgo-utxo-lib/src/index.js\", 7));\n  const bigi = await Promise.all(/*! import() */[__webpack_require__.e(4), __webpack_require__.e(8), __webpack_require__.e(33)]).then(__webpack_require__.t.bind(null, /*! bigi */ \"./node_modules/bigi/lib/index.js\", 7));\n  const bip38 = await Promise.all(/*! import() */[__webpack_require__.e(1), __webpack_require__.e(2), __webpack_require__.e(3), __webpack_require__.e(5), __webpack_require__.e(6), __webpack_require__.e(7), __webpack_require__.e(4), __webpack_require__.e(8), __webpack_require__.e(10), __webpack_require__.e(49), __webpack_require__.e(41)]).then(__webpack_require__.t.bind(null, /*! bip38 */ \"./node_modules/bip38/index.js\", 7));\n  const wif = await Promise.all(/*! import() */[__webpack_require__.e(1), __webpack_require__.e(2), __webpack_require__.e(26)]).then(__webpack_require__.t.bind(null, /*! wif */ \"./node_modules/wif/index.js\", 7));\n  const elliptic = await Promise.all(/*! import() */[__webpack_require__.e(3), __webpack_require__.e(21)]).then(__webpack_require__.t.bind(null, /*! elliptic */ \"./node_modules/elliptic/lib/elliptic.js\", 7));\n  const randombytes = (await __webpack_require__.e(/*! import() */ 28).then(__webpack_require__.t.bind(null, /*! randombytes */ \"./node_modules/randombytes/browser.js\", 7))).default;\n  const scrypt = await Promise.all(/*! import() */[__webpack_require__.e(1), __webpack_require__.e(2), __webpack_require__.e(3), __webpack_require__.e(5), __webpack_require__.e(6), __webpack_require__.e(7), __webpack_require__.e(38)]).then(__webpack_require__.t.bind(null, /*! scryptsy */ \"./node_modules/scryptsy/lib/index.js\", 7));\n  const base58 = await __webpack_require__.e(/*! import() */ 70).then(__webpack_require__.t.bind(null, /*! base58 */ \"./node_modules/base58/src/base58.js\", 7));\n  const bnjs = await Promise.all(/*! import() */[__webpack_require__.e(5), __webpack_require__.e(56)]).then(__webpack_require__.t.bind(null, /*! bn.js */ \"./node_modules/bn.js/lib/bn.js\", 7));\n  const aes = await Promise.all(/*! import() */[__webpack_require__.e(1), __webpack_require__.e(6), __webpack_require__.e(51)]).then(__webpack_require__.t.bind(null, /*! browserify-aes */ \"./node_modules/browserify-aes/browser.js\", 7));\n  const janin = await __webpack_require__.e(/*! import() */ 13).then(__webpack_require__.t.bind(null, /*! ./janin.currency.js */ \"./src/janin.currency.js\", 7));\n  const translator = await __webpack_require__.e(/*! import() */ 9).then(__webpack_require__.t.bind(null, /*! ./ninja.translator.js */ \"./src/ninja.translator.js\", 7));\n\n  const isPrivateKey = function (key) {\n    return janin.selectedCurrency.isPrivateKey(key);\n  };\n\n  const decodePrivateKey = function (key) {\n    if (!isPrivateKey(key)) {\n      return null;\n    }\n\n    return janin.selectedCurrency.decodePrivateKey(key);\n  };\n\n  const getAddressWith = function (btcKey, mode) {\n    return janin.selectedCurrency.getAddressWith(btcKey, mode);\n  };\n\n  const getWIFForAddress = function (btcKey, mode) {\n    return janin.selectedCurrency.getWIFForAddress(btcKey, mode);\n  };\n\n  const isVanitygenPossible = function (p, m) {\n    return janin.selectedCurrency.isVanitygenPossible(p, m);\n  };\n\n  const testVanitygenMatch = function (p, a, m) {\n    return janin.selectedCurrency.testVanitygenMatch(p, a, m);\n  }; // 58 base58 characters starting with 6P\n\n\n  const isBIP38Format = function (key) {\n    key = key.toString();\n    return /^6P[1-9A-HJ-NP-Za-km-z]{56}$/.test(key);\n  };\n\n  const BIP38EncryptedKeyToByteArrayAsync = function (base58Encrypted, passphrase, callback) {\n    // we're decrypting BIP38-encryped key\n    try {\n      const decryptedKey = bip38.decrypt(base58Encrypted, passphrase, function (status) {\n        console.log(status.percent);\n      });\n      callback(decryptedKey.privateKey);\n    } catch (e) {\n      callback(new Error(translator.get(\"detailalertnotvalidprivatekey\")));\n    }\n  };\n\n  const BIP38PrivateKeyToEncryptedKeyAsync = function (base58Key, passphrase, compressed, callback) {\n    // encrypt\n    const decoded = wif.decode(base58Key);\n    let encryptedKey = bip38.encrypt(decoded.privateKey, compressed, passphrase);\n    callback(encryptedKey);\n  };\n\n  const BIP38GenerateIntermediatePointAsync = function (passphrase, lotNum, sequenceNum, callback) {\n    const noNumbers = lotNum === null || sequenceNum === null;\n    let ownerEntropy, ownerSalt;\n\n    if (noNumbers) {\n      ownerSalt = ownerEntropy = randombytes(8);\n    } else {\n      // 1) generate 4 random bytes\n      ownerSalt = randombytes(4); // 2)  Encode the lot and sequence numbers as a 4 byte quantity (big-endian):\n      // lotnumber * 4096 + sequencenumber. Call these four bytes lotsequence.\n\n      const lotSequence = new bigi(4096 * lotNum + sequenceNum).toByteArrayUnsigned(); // 3) Concatenate ownersalt + lotsequence and call this ownerentropy.\n\n      ownerEntropy = ownerSalt.concat(lotSequence);\n    } // 4) Derive a key from the passphrase using scrypt\n\n\n    const prefactor = scrypt(passphrase, ownerSalt, 16384, 8, 8, 32); // Take SHA256(SHA256(prefactor + ownerentropy)) and call this passfactor\n\n    const passfactorBytes = noNumbers ? prefactor : bitcoin.crypto.hash256(prefactor.concat(ownerEntropy));\n    const passfactor = new bnjs(passfactorBytes); // 5) Compute the elliptic curve point G * passfactor, and convert the result to compressed notation (33 bytes)\n\n    const ellipticCurve = elliptic.curves.secp256k1.curve;\n    const passpoint = ellipticCurve.g.mul(passfactor).encodeCompressed(); // 6) Convey ownersalt and passpoint to the party generating the keys, along with a checksum to ensure integrity.\n    // magic bytes \"2C E9 B3 E1 FF 39 E2 51\" followed by ownerentropy, and then passpoint\n\n    const magicBytes = [0x2c, 0xe9, 0xb3, 0xe1, 0xff, 0x39, 0xe2, 0x51];\n    if (noNumbers) magicBytes[7] = 0x53;\n    let intermediate = magicBytes.concat(ownerEntropy).concat(passpoint); // base58check encode\n\n    intermediate = intermediate.concat(bitcoin.crypto.hash256(intermediate).slice(0, 4));\n    callback(base58.encode(intermediate));\n  };\n\n  const BIP38GenerateECAddressAsync = function (intermediate, compressed, callback) {\n    // decode IPS\n    const x = base58.decode(intermediate); //if(x.slice(49, 4) !== bitcoin.crypto.hash256(x.slice(0,49)).slice(0,4)) {\n    //\tcallback({error: 'Invalid intermediate passphrase string'});\n    //}\n\n    const noNumbers = x[7] === 0x53;\n    const ownerEntropy = x.slice(8, 8 + 8);\n    const passpoint = x.slice(16, 16 + 33); // 1) Set flagbyte.\n    // set bit 0x20 for compressed key\n    // set bit 0x04 if ownerentropy contains a value for lotsequence\n\n    const flagByte = (compressed ? 0x20 : 0x00) | (noNumbers ? 0x00 : 0x04); // 2) Generate 24 random bytes, call this seedb.\n\n    const seedB = randombytes(24); // Take SHA256(SHA256(seedb)) to yield 32 bytes, call this factorb.\n\n    const factorB = bitcoin.crypto.hash256(seedB); // 3) ECMultiply passpoint by factorb. Use the resulting EC point as a public key and hash it into a Bitcoin\n    // address using either compressed or uncompressed public key methodology (specify which methodology is used\n    // inside flagbyte). This is the generated Bitcoin address, call it generatedaddress.\n\n    const ellipticCurve = elliptic.curves.secp256k1.curve;\n    const generatedPoint = ellipticCurve.decodePoint(Buffer.from(passpoint));\n    const generatedBytes = generatedPoint.mul(new bnjs(factorB)).getEncoded(compressed);\n    const generatedAddress = bitcoin.address.toBase58Check(bitcoin.crypto.hash160(generatedBytes), 0); // 4) Take the first four bytes of SHA256(SHA256(generatedaddress)) and call it addresshash.\n\n    const addressHash = bitcoin.crypto.hash256(generatedAddress).slice(0, 4); // 5) Now we will encrypt seedb. Derive a second key from passpoint using scrypt\n\n    const derivedBytes = scrypt(passpoint, addressHash.concat(ownerEntropy), 1024, 1, 1, 64); // 6) Do AES256Encrypt(seedb[0...15]] xor derivedhalf1[0...15], derivedhalf2), call the 16-byte result encryptedpart1\n\n    for (let i = 0; i < 16; ++i) {\n      seedB[i] ^= derivedBytes[i];\n    }\n\n    const decipher1 = aes.createDecipher(\"aes-256-ecb\", seedB.slice(0, 16));\n    decipher1.setAutoPadding(false);\n    decipher1.end(derivedBytes.slice(16, 32));\n    const encryptedPart1 = decipher1.read(); // 7) Do AES256Encrypt((encryptedpart1[8...15] + seedb[16...23]) xor derivedhalf1[16...31], derivedhalf2), call the 16-byte result encryptedseedb.\n\n    const message2 = encryptedPart1.slice(8, 8 + 8).concat(seedB.slice(16, 16 + 8));\n\n    for (let i = 0; i < 16; ++i) {\n      message2[i] ^= derivedBytes[i + 16];\n    }\n\n    const decipher2 = aes.createDecipheriv(\"aes-256-ecb\", derivedBytes.slice(32));\n    decipher2.setAutoPadding(false);\n    decipher2.end(message2);\n    const encryptedSeedB = decipher2.read(); // 0x01 0x43 + flagbyte + addresshash + ownerentropy + encryptedpart1[0...7] + encryptedpart2\n\n    let encryptedKey = [0x01, 0x43, flagByte].concat(addressHash).concat(ownerEntropy).concat(encryptedPart1.slice(0, 8)).concat(encryptedSeedB); // base58check encode\n\n    encryptedKey = encryptedKey.concat(bitcoin.crypto.hash256(encryptedKey).slice(0, 4));\n    callback(generatedAddress, base58.encode(encryptedKey));\n  };\n\n  const create = function (d, Q, opts) {\n    return janin.selectedCurrency.create(d, Q, opts);\n  };\n\n  const makeRandom = function (opts) {\n    return janin.selectedCurrency.makeRandom(opts);\n  };\n\n  return {\n    isPrivateKey,\n    decodePrivateKey,\n    getAddressWith,\n    getWIFForAddress,\n    isBIP38Format,\n    BIP38EncryptedKeyToByteArrayAsync,\n    BIP38PrivateKeyToEncryptedKeyAsync,\n    BIP38GenerateIntermediatePointAsync,\n    BIP38GenerateECAddressAsync,\n    create,\n    makeRandom,\n    isVanitygenPossible,\n    testVanitygenMatch\n  };\n}();\n\nmodule.exports.__esModule = true;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./src/ninja.privatekey.js?");

/***/ })

}]);